---
-- These functions return a table of enemies for the provided parameters.
--
-- Enemies functions are stored in br.player.enemies and can be utilized by `local enemies = br.player.enemies` in your profile.
--
-- After defining enemies you would place the below functions in the main profile loop to populate and update the enemy tables.
--
-- Once done you can use variables such as these examples, you can also get count of enemies but just added a `#` in front of the variable name:
--
-- * `enemies.yards8` - Returns all enemies around player in 8yrds, generated by function enemies.get(8)
--
-- * `enemies.yards8t` - Returns all enemies around target in 8yrds, generated by function enemies.get(8,"target")
--
-- * `enemies.yards8tnc` - Returns all units around target in 8yrds, generated by function enemies.get(8,"target",true)
--
-- * `enemies.yards8tncf` - Returns all units the target is facing in 8yrds, generated by function enemies.get(8,"target",true,true)
--
-- For enemies in a cone it is the same as above but you use the `c` tag instead of `t`. Ex function: enemies.cone.get(45,8)
--
-- For enemies in a rectangle it is the same as above but you use the `r` tag instead of `t`. Ex function: enemies.rect.get(5,8)
--
-- @module br.player.enemies

local _, br = ...
if br.api == nil then br.api = {} end
local function setVariable(self, unit, range, checkNoCombat, facing, type, table, count)
    if unit == nil then unit = "player" end
    if range == nil then range = 5 end
    if checkNoCombat == nil then checkNoCombat = false end
    if facing == nil then facing = false end
    if type == nil then type = "" end
    if table == nil then table = {} end
    if count == nil then count = #table end
    -- Build enemies.yards variable
    local insertTable = "yards" ..
        range ..
        type -- Ex: enemies.yards8 (returns all enemies around player in 8yrds), Adds Table Type (r for Rect, c for Cone, blank for Normal)
    if unit ~= "player" then
        -- letter tag on end based on type of unit passed, if target or enemy unit then "t" otherwise first letter of what is passed in: f - "focus", p - "pet", m - "mouseover", etc
        if br.engines.enemiesEngine.units[unit] ~= nil then
            insertTable = insertTable .. "t" -- Ex: enemies.yards8t (returns all enemies around target in 8yrds)
        else
            insertTable = insertTable ..
                unit:sub(1, 1) -- Ex: enemies.yards8f (returns all enemies around "focus" in 8yrds)
        end
    end
    if checkNoCombat then insertTable = insertTable .. "nc" end -- Ex: enemies.yards8tnc (returns all units around target in 8yrds)
    if facing then insertTable = insertTable .. "f" end         -- Ex: enemies.yards8tncf (returns all units the target is facing in 8yrds)
    if self.enemies[insertTable] == nil then self.enemies[insertTable] = {} else br._G.wipe(self.enemies[insertTable]) end
    if count > 0 then br.functions.custom:insertTableIntoTable(self.enemies[insertTable], table) end
end

br.api.enemies = function(self)
    local enemies = self.enemies
    enemies.cone = enemies.cone or {}
    enemies.rect = enemies.rect or {}

    --- Returns a table of all enemies around unit for given range, combat situation, and facing
    -- @function enemies.get
    -- @number range The range to check for enemies
    -- @string unit The unit to check for enemies around
    -- @bool checkNoCombat Check for enemies even if not in combat
    -- @bool facing Check if enemies are facing unit
    -- @treturn table
    enemies.get = function(range, unit, checkNoCombat, facing)
        if unit == nil then unit = "player" end
        if checkNoCombat == nil then checkNoCombat = false end
        if facing == nil then facing = false end
        local enemyTable = br.engines.enemiesEngineFunctions:getEnemies(unit, range, checkNoCombat, facing)
        -- Build enemies.yards variable
        setVariable(self, unit, range, checkNoCombat, facing, "", enemyTable)
        -- Backwards compatability for old way
        return enemyTable, #enemyTable
    end

    --- Returns a table of all enemies in the players frontal cone for given angle, range, and combat situation
    -- @function enemies.cone.get
    -- @number angle The angle of the cone to check for enemies
    -- @number range The range to check for enemies
    -- @bool checkNoCombat Check for enemies even if not in combat
    -- @bool showLines Show lines for the cone *non-functional atm*
    -- @treturn table
    enemies.cone.get = function(angle, range, checkNoCombat, showLines)
        local count, table = br.engines.enemiesEngineFunctions:getEnemiesInCone(angle, range, checkNoCombat, showLines)
        -- Build enemies.yards variable
        setVariable(self, "player", range, checkNoCombat, false, "c", table, count)
        -- Backwards compatability for old way
        return table, count
    end

    --- Returns all enemies in a rectangular area from a unit for given range, combat situation, and facing
    -- @function enemies.rect.get
    -- @number width The width of the rectangle to check for enemies
    -- @number range The range to check for enemies
    -- @bool showLines Show lines for the rectangle *non-functional atm*
    -- @bool checkNoCombat Check for enemies even if not in combat
    -- @bool facing Check if enemies are facing unit *no longer used*
    -- @treturn table
    enemies.rect.get = function(width, range, showLines, checkNoCombat, facing)
        local count, table = br.engines.enemiesEngineFunctions:getEnemiesInRect(width, range, showLines, checkNoCombat)
        -- Build enemies.yards variable
        setVariable(self, "player", range, checkNoCombat, false, "r", table, count)
        -- Backwards compatability for old way
        return table, count
    end
end
